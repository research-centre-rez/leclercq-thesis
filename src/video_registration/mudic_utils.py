import sys
import logging
import muDIC as dic
import numpy as np


logger = logging.getLogger(__name__)


def create_mesh(
    h,
    w,
    image_stack: dic.IO.image_stack.ImageStack,
    box_w: int,
    box_h: int,
    num_elems_x: int,
    num_elems_y: int,
) -> dic.mesh.meshUtilities.Mesh:
    """
    Creates a mesh for the image_stack. The center of the mesh is placed in the center of the image. The user specifies the width and height of each cell and how many cells they want in the `x` and `y` axis.
    Args:
        `h, w`: height and width of the images in the image stack
        `image_stack` : image stack generated by muDIC
        `box_w, box_h` : width and height of each cell in the mesh
        `num_elems_x, num_elems_y` : number of cells in the `x` and `y` axis

    Returns:
        muDIC.Mesh object that can be used for muDIC correlation
    """
    center_h = h // 2
    center_w = w // 2

    offset_x = (box_w * num_elems_x) // 2
    offset_y = (box_h * num_elems_y) // 2

    logger.debug("Offset: %i %i", offset_x, offset_y)

    upp_x = center_w - offset_x
    low_x = center_w + offset_x

    upp_y = center_h - offset_y  # y=0 at the top of the image
    low_y = center_h + offset_y

    mesher = dic.Mesher()
    mesh = mesher.mesh(
        images=image_stack,
        Xc1=upp_x,
        Xc2=low_x,
        Yc1=upp_y,
        Yc2=low_y,
        n_elx=num_elems_x,
        n_ely=num_elems_y,
        GUI=False,
    )
    return mesh


def correlate_matrix(
    image_stack: dic.ImageStack,
    mesh: dic.mesh.meshUtilities.Mesh,
    ref_range: int,
    max_it: int,
) -> np.ndarray:
    """
    Calculates the displacement matrix for a video matrix. This is done via the use of the muDIC library.
    Args:
        `image_stack`: instance of mudic's ImageStack class
        `mesh`: mudic's mesh. Use `create_mesh` to create this
        `ref_range`: how often a reference frame is updated
        `max_it`: maximum number of iterations for correlating a pair of frames

    Returns:
        Displacement matrix of shape [1, 2, i, j, n] where (i,j) are number of cells in the `x` and `y` axis and `n` is the number of frames.
    """

    logger.debug("Image stack created successfully")

    ref_frames = list(np.arange(ref_range, len(image_stack), ref_range))

    logger.debug(f"Reference frame update will happen at these frames:\n  {ref_frames}")

    inputs = dic.DICInput(
        mesh=mesh,
        image_stack=image_stack,
        ref_update_frames=ref_frames,
        maxit=max_it,
        noconvergence="ignore",
        max_nr_im=len(image_stack),
    )

    dic_job = dic.DICAnalysis(inputs)

    # Sometimes the analysis finishes pre-emptively, I did not manage to find
    # a way of controling this behaviour. Notably, this is not determenistic
    # therefore running it again *might* fix it
    results = dic_job.run()  # runs the correlation procedure

    fields = dic.Fields(results)

    # TODO: Copy this information to README.md
    # The displacement is of shape [1, 2, i, j, n]
    # Where:
    # 1 because there is only one displacement matrix?
    # 2 due to decomposing the displacement vectors into cartesian coords
    # i = number of grids in horizontal direction
    # j = number of grids in vertical direction
    # n = number of images (=length of vid_mat)
    disp = fields.disp()
    
    # If the correlation fails, muDIC still returns incomplete displacement and doesn't
    # say whether there was an error or not
    if disp.shape[-1] != len(image_stack):
        logger.error("muDIC correlation failed to run on the whole image_stack")
        raise ValueError("MUDIC DID NOT RUN PROPERLY")

    return disp


def get_mesh_nodes(mesh: dic.mesh.meshUtilities.Mesh) -> np.ndarray:
    x_nodes = np.unique(mesh.xnodes)
    y_nodes = np.unique(mesh.ynodes)

    x_dist = np.diff(x_nodes)[0]
    x_centre = x_dist / 2

    y_dist = np.diff(y_nodes)[0]
    y_centre = y_dist / 2

    centre_nodes_x = np.arange(
        start=x_nodes[0] + x_centre, step=x_dist, stop=x_nodes[-1]
    )
    centre_nodes_y = np.arange(
        start=y_nodes[0] + y_centre, step=y_dist, stop=y_nodes[-1]
    )

    X, Y = np.meshgrid(centre_nodes_x, centre_nodes_y)
    nodes = np.column_stack([X.ravel(), Y.ravel()])
    return nodes

def extract_medians(displacement:np.ndarray):
    '''
    Extracts medians from displacement. Creates one median displacement instead of NxM displacement.
    '''
    medians = []
    for i in range(displacement.shape[-1]):
        x_med = np.median(displacement[0, :, :, i])
        y_med = np.median(displacement[1, :, :, i])
        medians.append([x_med, y_med])

    meds = np.array(medians)

    return meds

def extract_means(displacement:np.ndarray):
    '''
    Extracts means from displacement. Creates one mean displacement instead of NxM displacement.
    '''
    means = []
    for i in range(displacement.shape[-1]):
        x_mean = displacement[0, :, :, i].mean()
        y_mean = displacement[1, :, :, i].mean()
        means.append([x_mean, y_mean])

    means = np.array(means)

    return means
