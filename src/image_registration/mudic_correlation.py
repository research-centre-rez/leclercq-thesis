import sys
import os
import muDIC as dic
import numpy as np
import argparse
import logging

from image_registration import video_matrix
from utils import pprint
from utils import filename_builder

def parse_args():
    parser = argparse.ArgumentParser(description='Estimating correlation between individual frames of the video matrix')

    optional = parser._action_groups.pop()
    required = parser.add_argument_group('required arguments')

    # Required arguments
    required.add_argument('-i', '--input', type=str, required=True, help='Path to the input video, can be .npy file or .mp4')

    # Optional arguments
    optional = parser.add_argument_group('optional arguments')
    optional.add_argument('-o', '--save_as', type=str, help='Name of the output file')
    optional.add_argument('--box_h', type=int, default=100, help='Height of the correlation cell')
    optional.add_argument('--box_w', type=int, default=100, help='Width of the correlation cell')
    optional.add_argument('--num_elems_x', type=int, default=5, help='How many cells in the x axis')
    optional.add_argument('--num_elems_y', type=int, default=5, help='How many cells in the y axis')
    optional.add_argument('--max_it', type=int, default=50, help='Max number of iterations in the correlation step')
    optional.add_argument('--ref_range', type=int, default=25, help='How often should the ref frame be updated')

    return parser.parse_args()

def create_mesh(h,w, image_stack:dic.IO.image_stack.ImageStack, box_w:int, box_h:int, num_elems_x:int, num_elems_y:int) -> dic.mesh.meshUtilities.Mesh:
    '''
    Creates a mesh for the image_stack. The center of the mesh is placed in the center of the image. The user specifies the width and height of each cell and how many cells they want in the `x` and `y` axis.
    Args:
        `h, w`: height and width of the images in the image stack
        `image_stack` : image stack generated by muDIC
        `box_w, box_h` : width and height of each cell in the mesh
        `num_elems_x, num_elems_y` : number of cells in the `x` and `y` axis

    Returns:
        muDIC.Mesh object that can be used for muDIC correlation
    '''
    center_h = h // 2
    center_w = w // 2

    offset_x = (box_w * num_elems_x) // 2
    offset_y = (box_h * num_elems_y) // 2

    logger = logging.getLogger(__name__)

    logger.debug('Offset: %i %i', offset_x, offset_y)

    upp_x = center_w - offset_x
    low_x = center_w + offset_x

    upp_y = center_h - offset_y #y=0 at the top of the image
    low_y = center_h + offset_y

    mesher = dic.Mesher()
    mesh   = mesher.mesh(images=image_stack,
                         Xc1=upp_x,
                         Xc2=low_x,
                         Yc1=upp_y,
                         Yc2=low_y,
                         n_elx=num_elems_x,
                         n_ely=num_elems_y,
                         GUI=False)
    return mesh

def correlate_matrix(image_stack:dic.ImageStack, mesh:dic.mesh.meshUtilities.Mesh, ref_range:int, max_it:int) -> np.ndarray:
    '''
    Calculates the displacement matrix for a video matrix. This is done via the use of the muDIC library. 
    Args:
        `image_stack`: instance of mudic's ImageStack class 
        `mesh`: mudic's mesh. Use `create_mesh` to create this
        `ref_range`: how often a reference frame is updated
        `max_it`: maximum number of iterations for correlating a pair of frames

    Returns:
        Displacement matrix of shape [1, 2, i, j, n] where (i,j) are number of cells in the `x` and `y` axis and `n` is the number of frames.
    '''

    logger = logging.getLogger(__name__)

    logger.debug('Image stack created successfully')

    ref_frames = list(np.arange(ref_range, len(image_stack), ref_range))

    logger.debug(f'Reference frame update will happen at these frames:\n  {ref_frames}')

    inputs  = dic.DICInput(mesh=mesh,
                           image_stack=image_stack,
                           ref_update_frames=ref_frames,
                           maxit=max_it,
                           noconvergence='ignore',
                           max_nr_im=len(image_stack))

    dic_job = dic.DICAnalysis(inputs)

    # Sometimes the analysis finishes pre-emptively, I did not manage to find
    # a way of controling this behaviour. Notably, this is not determenistic
    # therefore running it again *might* fix it
    results = dic_job.run() # runs the correlation procedure

    fields = dic.Fields(results)

    # TODO: Copy this information to README.md
    # The displacement is of shape [1, 2, i, j, n]
    # Where:
    # 1 because there is only one displacement matrix?
    # 2 due to decomposing the displacement vectors into cartesian coords
    # i = number of grids in horizontal direction
    # j = number of grids in vertical direction
    # n = number of images (=length of vid_mat)
    disp = fields.disp()

    # FIXME: aaaa
    # If the correlation fails, muDIC still returns incomplete displacement and doesn't
    # say whether there was an error or not
    if disp.shape[-1] != len(image_stack):
        logger.error('muDIC correlation failed to run on the whole image_stack, exiting')
        sys.exit(-1)

    return disp

def get_mesh_nodes(mesh:dic.mesh.meshUtilities.Mesh) -> np.ndarray:
    x_nodes = np.unique(mesh.xnodes)
    y_nodes = np.unique(mesh.ynodes)

    x_dist   = np.diff(x_nodes)[0]
    x_centre = x_dist / 2

    y_dist   = np.diff(y_nodes)[0]
    y_centre = y_dist / 2

    centre_nodes_x = np.arange(start=x_nodes[0]+x_centre, step=x_dist, stop=x_nodes[-1])
    centre_nodes_y = np.arange(start=y_nodes[0]+y_centre, step=y_dist, stop=y_nodes[-1])

    X, Y = np.meshgrid(centre_nodes_x, centre_nodes_y)
    nodes = np.column_stack([X.ravel(), Y.ravel()])
    return nodes

def main(args):
    logging.basicConfig(level=logging.DEBUG, format='%(name)s:%(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    pprint.pprint_argparse(args, logger)

    base_name, file_ext = os.path.basename(args.input).split('.')

    if file_ext == 'mp4':
        logger.info('Processing .mp4 video')
        out = video_matrix.create_video_matrix(args.input)
        logger.info('Rotating video frames')
        vid_mat = video_matrix.rotate_frames(out, save_as=None)
    else:
        try:
            logger.info('Loading .npy file')
            vid_mat = np.load(args.input)
        except OSError as e:
            logger.info('Could not load the .npy file, please try again')
            logger.error(e)
            sys.exit(-1)

    image_stack = dic.image_stack_from_list(list(vid_mat[15:]))
    _, h, w = vid_mat.shape
    mesh = create_mesh(h, w, image_stack, args.box_h, args.box_w, args.num_elems_x, args.num_elems_y)
    mesh_nodes = get_mesh_nodes(mesh)
    displacement = correlate_matrix(image_stack, mesh, args.ref_range, args.max_it)


    if args.save_as is None:
        save_as = filename_builder.create_out_filename(base_name, [], ['displacement'])
        save_to = os.path.join('./npy_files', save_as)
        np.savez(save_to, displacement=displacement, mesh_nodes=mesh_nodes)
    else:
        np.savez(args.save_as, displacement=displacement, mesh_nodes=mesh_nodes)

if __name__ == "__main__":
    args = parse_args()
    main(args)
